"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedHeaders = void 0;
const common_1 = require("@nestjs/common");
const TypedHeaders = (options) => 
// eslint-disable-next-line @typescript-eslint/ban-types
(target, propertyKey, parameterIndex) => {
    const types = Reflect.getOwnMetadata('design:paramtypes', target, propertyKey);
    if (types === undefined) {
        throw new Error('Type metadata not found. See https://www.typescriptlang.org/docs/handbook/decorators.html#metadata');
    }
    const validationPipe = options?.validationPipe ?? new common_1.ValidationPipe({ transform: true });
    const paramType = types[parameterIndex];
    (0, common_1.Headers)()(target, propertyKey, parameterIndex);
    HeaderSchema({ paramType, validationPipe })(target, propertyKey, parameterIndex);
};
exports.TypedHeaders = TypedHeaders;
const HeaderSchema = (0, common_1.createParamDecorator)(async (options, ctx) => {
    // Extract headers
    const headers = ctx.switchToHttp().getRequest().headers;
    // Validate and transform
    return options.validationPipe.transform(headers, {
        type: 'body',
        metatype: options.paramType,
    });
});
//# sourceMappingURL=typed-headers.decorator.js.map